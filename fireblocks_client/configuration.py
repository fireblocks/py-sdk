# coding: utf-8

from urllib.parse import urlparse
"""
    Fireblocks API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.6.2
    Contact: support@fireblocks.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""

import os
import copy
import logging
import multiprocessing
import sys
import urllib3
import jwt
import time
import math
import secrets
import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
from hashlib import sha256

import http.client as httplib
from fireblocks_client.exceptions import ApiValueError
from typing import Optional, Dict, Any, Callable
from requests.models import PreparedRequest, Response

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class SDKOptions:
    def __init__(
        self,
        timeoutInMs: Optional[int] = None,
        proxy: Optional[Dict[str, Any]] = None,
        anonymousPlatform: Optional[bool] = None,
        userAgent: Optional[str] = None,
    ):
        self.timeoutInMs = timeoutInMs
        self.proxy = proxy
        self.anonymousPlatform = anonymousPlatform
        self.userAgent = userAgent
        self.retries = None
        self.connection_pool_maxsize= 3

    def get_default(self):
        options = SDKOptions()
        options.timeoutInMs = 10000
        options.proxy = None
        options.anonymousPlatform = None
        options.userAgent = None
        options.retries = None
        options.connection_pool_maxsize= 3
        return options

class Configuration(object):
    _base_path:str = ""
    _api_key:str = ""
    _secret_key:str = ""

    def __init__(self, base_path: str =None, api_key: str=None, secret_key: str=None, connection_pool_maxsize: int=None, options: SDKOptions=None):
        self._base_path = base_path or "https://api.fireblocks.io/v1"
        if base_path is not None:
            self._base_path = os.environ["FIREBLOCKS_BASE_PATH"]
        elif os.environ["FIREBLOCKS_BASE_PATH"] is None:
            self._base_path = os.environ["FIREBLOCKS_BASE_PATH"]

        self._api_key = api_key
        if os.environ["FIREBLOCKS_API_KEY"] is not None and self._api_key is None:
            self._api_key = os.environ["FIREBLOCKS_API_KEY"]
        if self._api_key is None:
            raise ValueError("api_key is missing please provide it and try again")

        self._secret_key = secret_key
        if os.environ["FIREBLOCKS_SECRET_KEY"] is not  None and self._secret_key is None:
            self._secret_key = os.environ["FIREBLOCKS_SECRET_KEY"]
        if self._secret_key is None:
            raise ValueError("secret_key is missing please provide it and try again")

        self._sdk_options = options
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("fireblocks_client")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.connection_pool_maxsize = None

    def get_default(self):
        conf = Configuration()
        if os.environ["FIREBLOCKS_BASE_PATH"] is not None:
            conf._base_path = os.environ["FIREBLOCKS_BASE_PATH"]
        elif self._base_path is None:
            conf._base_path = "https://api.fireblocks.io/v1"

        if os.environ["FIREBLOCKS_API_KEY"] is not  None:
            conf._api_key = os.environ["FIREBLOCKS_API_KEY"]
        else:
            raise ValueError("api_key is missing please provide it and try again")

        if os.environ["FIREBLOCKS_SECRET_KEY"] is not  None:
            conf._secret_key = os.environ["FIREBLOCKS_SECRET_KEY"]
        else:
            raise ValueError("secret_key is missing please provide it and try again")

        conf._options = SDKOptions().get_default()

        conf.connection_pool_maxsize = None

        return conf

    def sign_jwt(self, path, body_json=""):
        url_path = urlparse(self._base_path + path).path
        timestamp = time.time()
        nonce = secrets.randbits(63)
        timestamp_secs = math.floor(timestamp)
        path= path.replace("[", "%5B")
        path= path.replace("]", "%5D")
        to_dict_op = getattr(body_json,"to_dict",None)
        if to_dict_op is not None:
            body_json = to_dict_op()
        token = {
            "uri": url_path,
            "nonce": nonce,
            "iat": timestamp_secs,
            "exp": timestamp_secs + 55,
            "sub": self._api_key,
            "bodyHash": sha256(json.dumps(body_json).encode("utf-8")).hexdigest()
        }

        return jwt.encode(token, key=self._secret_key, algorithm="RS256")

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, options):
        self._options = options

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default `logging.WARNING`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        if self.access_token is not None:
            auth['bearerTokenAuth'] = {
                'type': 'bearer',
                'in': 'header',
                'format': 'JWT',
                'key': 'Authorization',
                'value': 'Bearer ' + self.access_token
            }
        if 'ApiKeyAuth' in self.api_key:
            auth['ApiKeyAuth'] = {
                'type': 'api_key',
                'in': 'header',
                'key': 'X-API-Key',
                'value': self.get_api_key_with_prefix(
                    'ApiKeyAuth',
                ),
            }
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\n"\
               "OS: {env}\n"\
               "Python Version: {pyversion}\n"\
               "Version of the API: 1.6.2\n"\
               "SDK Package Version: 1.0.0".\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "https://api.fireblocks.io/v1",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable `{0}` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
